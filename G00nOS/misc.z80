
CTRL_C: equ 3

system:		; command in hl
	push bc
	push de
	push hl
	ld de, os_str_buffer
	call get_token
	ld (.token_op), hl
	ld a, (de)
	cp CTRL_C
	jp z, os_quit
	
	ld hl, .cmd_format_str
	call strcomp
	jr z, .cmd_format
	
	ld hl, .cmd_ls_str
	call strcomp
	jr z, .cmd_ls
	
	ld hl, .cmd_cls_str
	call strcomp
	jr z, .cmd_cls
	
	ld hl, .cmd_mkdir_str
	call strcomp
	jp z, .cmd_mkdir
	
	ld hl, .cmd_flash_str
	call strcomp
	jp z, os_quit
	
	ld hl, .commandNotFound		; oops!!
	call print
	
	ex de, hl
	call println
	
	pop hl
	pop de
	pop bc
	ret
.cmd_cls:
	call gfx_clear
	jp .done
.cmd_format:
	ld hl, (.token_op)		; get argument
	ld de, os_str_buffer
	call get_token
	
	ld a, (de)				; is there an argument?
	or a
	jp z, .format_usage		; go to .format_usage if not
	
	ex de, hl
	call hex_to_int
	
	ld b, h
	ld c, l
	ld hl, (main_disk)
	call gfs_format
	
	jp .done
.cmd_ls:
	ld hl, (.token_op)
	ld de, os_str_buffer
	call get_token
	ex de, hl
	
	ld a, (hl)				; is there an argument?
	or a
	jp nz, .ls_has_arg		; go to .format_usage if so
	
	; oterwise use root_str
	ld hl, root_str
.ls_has_arg:
	jp .ls_clutch
db 0,"system.ls_clutch", 0
.ls_clutch:
	call ld_dir_table
	ld de, GFS_root
	ld hl, (main_disk)
	call blockdevice.read
	
	ld b, 64
.ls_loop:
	call gfs_nextfile
	call file_obj.isDir
	jp nz, .ls_pdir
	call file_obj.isFile
	jp nz, .ls_pfile
.ls__next:
	djnz .ls_loop
	
	ld a, $0D
	call chrout
	
	jp .done
.ls_pdir:
	call file_obj.get_name
	call print
	ld a, '/'
	call chrout
	ld a, ' '
	call chrout
	jp .ls__next
.ls_pfile:
	call file_obj.get_name
	call print
	ld a, ' '
	call chrout
	jp .ls__next
.done:
	pop hl
	pop de
	pop bc
	ret
.cmd_mkdir:
	ld hl, (.token_op)		; get argument
	ld de, os_str_buffer_3
	call get_token
	ex de, hl
	
	ld a, (hl)				; is there an argument?
	or a
	jp z, .mkdir_usage		; go to .mkdir_usage if not
	
	call gfs_mkdir
	
	jp .done
.format_usage:
	ld hl, .format_usage_str
	call println
	jp .done
.mkdir_usage:
	ld hl, .mkdir_usage_str
	call println
	jp .done
.token_op: dw 0
.cmd_flash_str: db"flash", 0
.cmd_format_str: db "format", 0
.cmd_ls_str: db "ls", 0
.cmd_cls_str: db "cls", 0
.cmd_mkdir_str: db "mkdir", 0
.cmd_rm_str: db "rm", 0
.commandNotFound: db "Command not found: ", 0

.format_usage_str: db "Usage: format [num sectors in hex]", 0
.mkdir_usage_str: db "Usage: mkdir [dirpath]", 0


get_token:	; arguments: source in hl, destination in de.  Returns: hl is pointer of next string
	push de
.skip_loop:
	ld a, (hl)
	or a
	jp z, .empty
	inc hl
	cp ' '
	jp z, .skip_loop
	cp 9
	jp z, .skip_loop
	cp 10
	jp z, .skip_loop
	cp 13
	jp z, .skip_loop
	
.copy_loop:
	ld (de), a
	inc de
	ld a, (hl)
	or a
	jp z, .done
	
	inc hl
	
	cp ' '
	jp z, .done
	cp 9
	jp z, .done
	cp 10
	jp z, .done
	cp 13
	jp z, .done
	
	jp .copy_loop
.empty:
	
.done:
	xor a		; finish string and restore pointer
	ld (de), a
	pop de
	
	ret
	
	
	
	
	
